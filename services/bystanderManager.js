// services/bystanderManager.js

class BystanderManager {
  constructor() {
    this.bystanderTypes = this.initializeBystanderTypes();
    this.currentBystanders = [];
    this.interactionHistory = [];
  }

  /**
   * Initialize different types of bystanders and their characteristics
   * @returns {Object} - Bystander type configurations
   */
  initializeBystanderTypes() {
    return {
      family: {
        relationship: ['spouse', 'parent', 'child', 'sibling'],
        emotionalState: ['worried', 'panicked', 'helpful', 'protective'],
        knowledgeLevel: 'high', // Knows patient well
        helpfulness: 0.8,
        interference: 0.3
      },
      
      coworker: {
        relationship: ['colleague', 'supervisor', 'employee'],
        emotionalState: ['concerned', 'professional', 'nervous'],
        knowledgeLevel: 'medium', // Some knowledge of patient
        helpfulness: 0.7,
        interference: 0.2
      },
      
      friend: {
        relationship: ['friend', 'acquaintance', 'neighbor'],
        emotionalState: ['worried', 'supportive', 'uncertain'],
        knowledgeLevel: 'medium',
        helpfulness: 0.6,
        interference: 0.3
      },
      
      stranger: {
        relationship: ['passerby', 'witness', 'good samaritan'],
        emotionalState: ['curious', 'helpful', 'nervous', 'distant'],
        knowledgeLevel: 'low', // Little to no knowledge of patient
        helpfulness: 0.4,
        interference: 0.5
      },
      
      crowd: {
        relationship: ['onlookers', 'crowd', 'bystanders'],
        emotionalState: ['curious', 'anxious', 'disruptive'],
        knowledgeLevel: 'low',
        helpfulness: 0.2,
        interference: 0.8
      }
    };
  }

  /**
   * Generate bystanders based on scenario location and type
   * @param {Object} scenarioData - Current scenario data
   * @returns {Array} - Generated bystanders
   */
  generateBystanders(scenarioData) {
    const location = scenarioData?.generatedScenario?.dispatchInfo?.location?.toLowerCase() || '';
    const difficulty = scenarioData?.generatedScenario?.difficulty?.level || 'intermediate';
    
    // Determine bystander probability based on location
    const bystanderProbability = this.getBystanderProbability(location);
    
    this.currentBystanders = [];
    
    // Only generate bystanders sometimes (not every scenario)
    if (Math.random() > bystanderProbability) {
      return this.currentBystanders;
    }

    // Determine bystander types based on location
    const possibleTypes = this.getBystanderTypesForLocation(location);
    const numBystanders = this.determineBystanderCount(location, difficulty);
    
    for (let i = 0; i < numBystanders; i++) {
      const bystanderType = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];
      const bystander = this.createBystander(bystanderType, scenarioData);
      this.currentBystanders.push(bystander);
    }

    console.log('ðŸ‘¥ Generated bystanders:', this.currentBystanders.length);
    return this.currentBystanders;
  }

  /**
   * Get bystander probability based on location type
   * @param {string} location - Location description
   * @returns {number} - Probability of bystanders (0-1)
   */
  getBystanderProbability(location) {
    if (/(home|house|apartment|residential)/.test(location)) return 0.6;
    if (/(office|workplace|business)/.test(location)) return 0.7;
    if (/(mall|restaurant|public|park|school)/.test(location)) return 0.8;
    if (/(highway|road|rural)/.test(location)) return 0.3;
    if (/(hospital|clinic)/.test(location)) return 0.9;
    return 0.5; // Default
  }

  /**
   * Get appropriate bystander types for location
   * @param {string} location - Location description
   * @returns {Array} - Possible bystander types
   */
  getBystanderTypesForLocation(location) {
    if (/(home|house|apartment|residential)/.test(location)) {
      return ['family', 'friend', 'stranger'];
    }
    if (/(office|workplace|business)/.test(location)) {
      return ['coworker', 'stranger'];
    }
    if (/(mall|restaurant|public|park|school)/.test(location)) {
      return ['stranger', 'crowd', 'friend'];
    }
    if (/(highway|road)/.test(location)) {
      return ['stranger', 'family'];
    }
    return ['stranger', 'friend'];
  }

  /**
   * Determine number of bystanders based on location and difficulty
   * @param {string} location - Location description
   * @param {string} difficulty - Scenario difficulty
   * @returns {number} - Number of bystanders to generate
   */
  determineBystanderCount(location, difficulty) {
    let baseCount = 1;
    
    // Location modifiers
    if (/(mall|restaurant|public|park|school|crowd)/.test(location)) {
      baseCount = 2;
    }
    if (/(highway|road|rural)/.test(location)) {
      baseCount = Math.random() < 0.5 ? 0 : 1;
    }
    
    // Difficulty modifiers
    if (difficulty === 'advanced') {
      baseCount += Math.random() < 0.3 ? 1 : 0; // Sometimes add complexity
    }
    
    return Math.min(baseCount, 3); // Cap at 3 bystanders
  }

  /**
   * Create a specific bystander with characteristics
   * @param {string} bystanderType - Type of bystander
   * @param {Object} scenarioData - Scenario data for context
   * @returns {Object} - Created bystander
   */
  createBystander(bystanderType, scenarioData) {
    const config = this.bystanderTypes[bystanderType];
    const patientAge = scenarioData?.generatedScenario?.patientProfile?.age || 45;
    const patientGender = scenarioData?.generatedScenario?.patientProfile?.gender || 'male';
    
    const bystander = {
      id: `bystander_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: bystanderType,
      relationship: config.relationship[Math.floor(Math.random() * config.relationship.length)],
      emotionalState: config.emotionalState[Math.floor(Math.random() * config.emotionalState.length)],
      knowledgeLevel: config.knowledgeLevel,
      helpfulness: config.helpfulness,
      interference: config.interference,
      hasSpoken: false,
      informationProvided: [],
      conflictingInfo: Math.random() < 0.2 // 20% chance of providing conflicting information
    };

    // Generate specific information this bystander knows
    bystander.knownInformation = this.generateBystanderKnowledge(bystander, scenarioData);
    
    return bystander;
  }

  /**
   * Generate what information a bystander knows about the patient/situation
   * @param {Object} bystander - Bystander object
   * @param {Object} scenarioData - Scenario data
   * @returns {Object} - Information the bystander knows
   */
  generateBystanderKnowledge(bystander, scenarioData) {
    const knowledge = {
      patientName: false,
      medicalHistory: false,
      medications: false,
      allergies: false,
      eventWitness: false,
      symptoms: false,
      timeline: false
    };

    const knowledgeChances = {
      high: { patientName: 0.9, medicalHistory: 0.8, medications: 0.7, allergies: 0.8, eventWitness: 0.6, symptoms: 0.9, timeline: 0.8 },
      medium: { patientName: 0.7, medicalHistory: 0.4, medications: 0.3, allergies: 0.4, eventWitness: 0.5, symptoms: 0.7, timeline: 0.6 },
      low: { patientName: 0.2, medicalHistory: 0.1, medications: 0.0, allergies: 0.1, eventWitness: 0.8, symptoms: 0.5, timeline: 0.4 }
    };

    const chances = knowledgeChances[bystander.knowledgeLevel];
    
    Object.keys(knowledge).forEach(key => {
      knowledge[key] = Math.random() < chances[key];
    });

    return knowledge;
  }

  /**
   * Generate bystander response to EMT question or action
   * @param {string} emtMessage - What the EMT said/asked
   * @param {Object} scenarioData - Current scenario data
   * @returns {string|null} - Bystander response or null if no response
   */
  generateBystanderResponse(emtMessage, scenarioData) {
    if (this.currentBystanders.length === 0) {
      return null;
    }

    const normalizedMessage = emtMessage.toLowerCase();
    
    // Determine if any bystander should respond
    const respondingBystander = this.selectRespondingBystander(normalizedMessage);
    
    if (!respondingBystander) {
      return null;
    }

    // Generate appropriate response
    const response = this.generateSpecificBystanderResponse(respondingBystander, normalizedMessage, scenarioData);
    
    // Record the interaction
    this.interactionHistory.push({
      timestamp: Date.now(),
      bystanderId: respondingBystander.id,
      emtMessage: emtMessage,
      bystanderResponse: response
    });

    respondingBystander.hasSpoken = true;
    
    return response;
  }

  /**
   * Select which bystander should respond to EMT
   * @param {string} normalizedMessage - Normalized EMT message
   * @returns {Object|null} - Responding bystander or null
   */
  selectRespondingBystander(normalizedMessage) {
    // Questions that would prompt bystander responses
    const bystanderTriggers = [
      /(what happened|tell me|witness|see|know)/,
      /(name|who is|patient)/,
      /(medication|pills|take|allerg)/,
      /(history|condition|problem)/,
      /(when|how long|start)/,
      /(move back|step back|give.*space)/
    ];

    const shouldRespond = bystanderTriggers.some(trigger => trigger.test(normalizedMessage));
    
    if (!shouldRespond) {
      return null;
    }

    // Select bystander based on helpfulness and whether they've already spoken
    const availableBystanders = this.currentBystanders.filter(b => 
      !b.hasSpoken || Math.random() < 0.3 // 30% chance spoken bystander responds again
    );

    if (availableBystanders.length === 0) {
      return null;
    }

    // Weight selection by helpfulness
    const weights = availableBystanders.map(b => b.helpfulness);
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    const random = Math.random() * totalWeight;
    
    let cumulativeWeight = 0;
    for (let i = 0; i < availableBystanders.length; i++) {
      cumulativeWeight += weights[i];
      if (random <= cumulativeWeight) {
        return availableBystanders[i];
      }
    }

    return availableBystanders[0]; // Fallback
  }

  /**
   * Generate specific response from a bystander
   * @param {Object} bystander - Responding bystander
   * @param {string} normalizedMessage - Normalized EMT message
   * @param {Object} scenarioData - Scenario data
   * @returns {string} - Bystander response
   */
  generateSpecificBystanderResponse(bystander, normalizedMessage, scenarioData) {
    const patientProfile = scenarioData?.generatedScenario?.patientProfile || {};
    const presentation = scenarioData?.generatedScenario?.presentation || {};
    
    // Handle crowd control requests
    if (/(move back|step back|give.*space|crowd)/.test(normalizedMessage)) {
      return this.generateCrowdControlResponse(bystander);
    }

    // Handle information requests
    if (/(what happened|tell me|witness|see)/.test(normalizedMessage)) {
      return this.generateWitnessResponse(bystander, scenarioData);
    }

    if (/(name|who is)/.test(normalizedMessage)) {
      return this.generateNameResponse(bystander, patientProfile);
    }

    if (/(medication|pills|take)/.test(normalizedMessage)) {
      return this.generateMedicationResponse(bystander, patientProfile);
    }

    if (/(allerg)/.test(normalizedMessage)) {
      return this.generateAllergyResponse(bystander, patientProfile);
    }

    if (/(history|condition|problem)/.test(normalizedMessage)) {
      return this.generateHistoryResponse(bystander, patientProfile);
    }

    if (/(when|how long|start)/.test(normalizedMessage)) {
      return this.generateTimelineResponse(bystander, presentation);
    }

    // Default emotional response based on bystander state
    return this.generateEmotionalResponse(bystander);
  }

  /**
   * Generate crowd control response
   * @param {Object} bystander - Responding bystander
   * @returns {string} - Response to crowd control
   */
  generateCrowdControlResponse(bystander) {
    const responses = {
      helpful: ['Of course, we\'ll give you space.', 'Sorry, we\'ll move back.'],
      worried: ['Is he going to be okay?', 'Please help him!'],
      resistant: ['We just want to help!', 'Can\'t we stay close?'],
      compliant: ['Okay, we\'re moving back.', 'We\'ll stay out of your way.']
    };

    const responseType = bystander.interference > 0.6 ? 'resistant' : 
                        bystander.emotionalState === 'worried' ? 'worried' :
                        bystander.helpfulness > 0.7 ? 'helpful' : 'compliant';

    const options = responses[responseType];
    return `**[${bystander.relationship}]** ${options[Math.floor(Math.random() * options.length)]}`;
  }

  /**
   * Generate witness account response
   * @param {Object} bystander - Responding bystander
   * @param {Object} scenarioData - Scenario data
   * @returns {string} - Witness response
   */
  generateWitnessResponse(bystander, scenarioData) {
    if (!bystander.knownInformation.eventWitness) {
      return `**[${bystander.relationship}]** I didn't see what happened, I just found them like this.`;
    }

    const mechanism = scenarioData?.generatedScenario?.dispatchInfo?.mechanism || 'unknown incident';
    const conflictingInfo = bystander.conflictingInfo;
    
    if (conflictingInfo) {
      // Provide slightly different or confused information
      const confusedResponses = [
        `**[${bystander.relationship}]** I think they ${mechanism}, but I'm not sure exactly what happened.`,
        `**[${bystander.relationship}]** It happened so fast, they were complaining about pain and then just collapsed.`,
        `**[${bystander.relationship}]** I heard them say something about ${mechanism}, but I might be wrong.`
      ];
      return confusedResponses[Math.floor(Math.random() * confusedResponses.length)];
    }

    return `**[${bystander.relationship}]** I saw them ${mechanism}. It just happened a few minutes ago.`;
  }

  /**
   * Generate name response
   * @param {Object} bystander - Responding bystander
   * @param {Object} patientProfile - Patient profile
   * @returns {string} - Name response
   */
  generateNameResponse(bystander, patientProfile) {
    if (!bystander.knownInformation.patientName) {
      return `**[${bystander.relationship}]** I don't know their name.`;
    }

    // Use generic name for simulation
    const names = ['John Smith', 'Mary Johnson', 'David Wilson', 'Sarah Brown'];
    const name = names[Math.floor(Math.random() * names.length)];
    
    return `**[${bystander.relationship}]** Their name is ${name}.`;
  }

  /**
   * Generate medication response
   * @param {Object} bystander - Responding bystander
   * @param {Object} patientProfile - Patient profile
   * @returns {string} - Medication response
   */
  generateMedicationResponse(bystander, patientProfile) {
    if (!bystander.knownInformation.medications) {
      return `**[${bystander.relationship}]** I don't know what medications they take.`;
    }

    const medications = patientProfile.medications || ['none'];
    if (medications.length === 1 && medications[0] === 'none') {
      return `**[${bystander.relationship}]** I don't think they take any regular medications.`;
    }

    if (bystander.conflictingInfo) {
      return `**[${bystander.relationship}]** I think they take something for their heart, but I'm not sure what.`;
    }

    return `**[${bystander.relationship}]** They take ${medications.join(', ')}.`;
  }

  /**
   * Generate allergy response
   * @param {Object} bystander - Responding bystander
   * @param {Object} patientProfile - Patient profile
   * @returns {string} - Allergy response
   */
  generateAllergyResponse(bystander, patientProfile) {
    if (!bystander.knownInformation.allergies) {
      return `**[${bystander.relationship}]** I don't know about any allergies.`;
    }

    const allergies = patientProfile.allergies || ['none'];
    if (allergies.length === 1 && allergies[0] === 'none') {
      return `**[${bystander.relationship}]** I don't think they have any allergies.`;
    }

    return `**[${bystander.relationship}]** They're allergic to ${allergies.join(', ')}.`;
  }

  /**
   * Generate medical history response
   * @param {Object} bystander - Responding bystander
   * @param {Object} patientProfile - Patient profile
   * @returns {string} - History response
   */
  generateHistoryResponse(bystander, patientProfile) {
    if (!bystander.knownInformation.medicalHistory) {
      return `**[${bystander.relationship}]** I don't know much about their medical history.`;
    }

    const history = patientProfile.medicalHistory || ['none'];
    if (history.length === 1 && history[0] === 'none') {
      return `**[${bystander.relationship}]** I don't think they have any major health problems.`;
    }

    return `**[${bystander.relationship}]** They have a history of ${history.join(', ')}.`;
  }

  /**
   * Generate timeline response
   * @param {Object} bystander - Responding bystander
   * @param {Object} presentation - Patient presentation
   * @returns {string} - Timeline response
   */
  generateTimelineResponse(bystander, presentation) {
    if (!bystander.knownInformation.timeline) {
      return `**[${bystander.relationship}]** I'm not sure exactly when it started.`;
    }

    const onset = presentation.onsetTime || '30 minutes ago';
    
    if (bystander.conflictingInfo) {
      const confusedTimes = ['about an hour ago', 'maybe 20 minutes', 'just a few minutes ago'];
      const confusedTime = confusedTimes[Math.floor(Math.random() * confusedTimes.length)];
      return `**[${bystander.relationship}]** I think it started ${confusedTime}, but I might be wrong.`;
    }

    return `**[${bystander.relationship}]** It started ${onset}.`;
  }

  /**
   * Generate emotional response when no specific information requested
   * @param {Object} bystander - Responding bystander
   * @returns {string} - Emotional response
   */
  generateEmotionalResponse(bystander) {
    const responses = {
      worried: ['Please help them!', 'Are they going to be okay?', 'This is so scary!'],
      panicked: ['Oh my god, what\'s happening?', 'Do something!', 'Is this serious?'],
      helpful: ['What can I do to help?', 'Should I call someone?', 'Let me know if you need anything.'],
      protective: ['Be careful with them!', 'Don\'t hurt them!', 'They\'re in pain!'],
      nervous: ['I don\'t know what to do.', 'This is terrible.', 'I hope they\'ll be alright.'],
      curious: ['What\'s wrong with them?', 'What are you doing?', 'Is that normal?']
    };

    const stateResponses = responses[bystander.emotionalState] || responses.nervous;
    const response = stateResponses[Math.floor(Math.random() * stateResponses.length)];
    
    return `**[${bystander.relationship}]** ${response}`;
  }

  /**
   * Check if bystanders should create complications
   * @param {string} emtAction - Current EMT action
   * @returns {string|null} - Complication description or null
   */
  checkForComplications(emtAction) {
    if (this.currentBystanders.length === 0) {
      return null;
    }

    const highInterferenceBystanders = this.currentBystanders.filter(b => b.interference > 0.6);
    
    if (highInterferenceBystanders.length === 0) {
      return null;
    }

    // Random chance of interference
    if (Math.random() > 0.3) {
      return null;
    }

    const complications = [
      'A bystander keeps trying to help despite your requests to step back.',
      'Family members are becoming increasingly agitated and demanding answers.',
      'The crowd is growing and making it difficult to work.',
      'A bystander is contradicting your instructions to the patient.',
      'Someone is taking photos/video of the scene, creating distractions.'
    ];

    return complications[Math.floor(Math.random() * complications.length)];
  }

  /**
   * Reset bystander manager for new scenario
   */
  reset() {
    this.currentBystanders = [];
    this.interactionHistory = [];
    console.log('ðŸ‘¥ Bystander manager reset');
  }

  /**
   * Generate bystander response to EMT action/question
   * @param {string} userMessage - EMT message
   * @param {Object} actionResult - Recognized action (optional)
   * @returns {string|null} - Bystander response or null
   */
  generateResponse(userMessage, actionResult = null) {
    if (this.currentBystanders.length === 0) {
      return null;
    }

    const normalizedMessage = userMessage.toLowerCase();
    const respondingBystander = this.selectRespondingBystander(normalizedMessage);
    
    if (!respondingBystander) {
      return null;
    }

    // Generate appropriate response based on message content
    let response = this.generateBystanderDialogue(respondingBystander, normalizedMessage);
    
    // Mark bystander as having spoken
    respondingBystander.hasSpoken = true;
    
    console.log('ðŸ‘¥ Bystander response generated:', { 
      type: respondingBystander.type, 
      response: response.substring(0, 50) + '...' 
    });
    
    return response;
  }

  /**
   * Reset bystander manager for new scenario
   */
  reset() {
    this.currentBystanders = [];
    this.scenarioLocation = null;
    console.log('ðŸ”„ Bystander manager reset');
  }

  /**
   * Get current bystander status for scenario context
   * @returns {Object} - Current bystander status
   */
  getBystanderStatus() {
    return {
      count: this.currentBystanders.length,
      types: this.currentBystanders.map(b => b.type),
      averageHelpfulness: this.currentBystanders.reduce((sum, b) => sum + b.helpfulness, 0) / Math.max(this.currentBystanders.length, 1),
      averageInterference: this.currentBystanders.reduce((sum, b) => sum + b.interference, 0) / Math.max(this.currentBystanders.length, 1),
      hasSpoken: this.currentBystanders.filter(b => b.hasSpoken).length
    };
  }
}

module.exports = BystanderManager;
